---
layout: post
title: "Reactive Programming"
date: 2025-06-29 11:28:00 +0000
categories: [programming]
tags: [reactive, programming, async, streams, tech]
excerpt: "리액티브 프로그래밍은 데이터 스트림과 변경 전파에 초점을 맞춘 선언적 프로그래밍 패러다임입니다."
notion_id: 221eef64-a1ca-8088-9f2b-e8a4c6d10e98
notion_url: https://www.notion.so/Reactive-Programming-221eef64a1ca80889f2be8a4c6d10e98
---

# Reactive Programming

리액티브 프로그래밍은 현대 소프트웨어 개발에서 매우 중요한 패러다임 중 하나입니다. "데이터 스트림"과 "변경 전파"에 초점을 맞춘 **선언적(Declarative) 프로그래밍 패러다임**입니다.


<!--more-->
## 리액티브 프로그래밍이란?

핵심 개념들을 살펴보겠습니다.

1. **데이터 스트림 (Data Streams)**
1. **변경 전파 (Propagation of Change)**
1. **선언적 프로그래밍 (Declarative Programming)**
1. **비동기성 (Asynchrony) 및 논블로킹 (Non-Blocking)**
1. **역압 (Backpressure)**
### 리액티브 프로그래밍이 나오게 된 이유

리액티브 프로그래밍이 등장하고 중요해진 배경에는 몇 가지 핵심적인 IT 환경의 변화가 있습니다.

1. **확대되는 동시성 요구 및 대규모 트래픽 처리**
1. **다양한 비동기 이벤트 처리의 복잡성 증가**
1. **데이터 중심 및 스트림 처리의 중요성 증대**
1. **마이크로 서비스 아키텍처의 확산**
1. **Reactive Manifesto의 등장**
**쉬운 프로그래밍인가?** 에 대한 답은 **"특정 상황에서는 그렇지만, 항상 그렇지는 않다"** 입니다.

리액티브 프로그래밍, 특히 비동기 논블로킹(Non-Blocking) I/O 모델을 기반으로 하는 경우, 서버 애플리케이션의 **처리량(Throughput)**과 **자원 효율성**을 극대화하는 데 매우 강력한 도구임은 분명합니다.

### 리액티브 프로그래밍의 성능 이점 (서버 기준)

1. **높은 동시성 처리 및 처리량 증가**:
1. **자원 효율성**
1. **응답성 향상**
### 리액티브 프로그래밍의 한계 및 고려사항

하지만 리액티브 프로그래밍이 모든 상황에서 만능의 해결책은 아닙니다. 다음과 같은 단점과 고려사항이 있습니다.

1. **높은 학습 곡선 및 복잡성**
1. **모든 작업에 적합하지 않음**
1. **생태계 지원**
1. **역압(Backpressure) 관리의 어려움**
### 결론

서버 환경에서 리액티브 프로그래밍은 다음과 같은 경우에 **매우 강력한 성능 이점**을 제공합니다:

- **높은 동시 요청 처리**가 필요한 대규모 서비스
- **I/O 바운드 작업**이 주를 이루는 애플리케이션 (데이터베이스 조회, 외부 API 호출, 네트워크 통신 등)
- **자원 효율성**을 극대화하여 서버 비용을 절감하고자 하는 경우
하지만 **개발 복잡도 증가, 학습 곡선, 그리고 특정 워크로드(CPU 집약적)에 대한 비효율성**이라는 단점도 명확합니다.

## 그렇다면 리액티브 프로그래밍이 가장 이상적인 프로그래밍인가?

당연히 그건 아닙니다.

따라서 "가장 성능을 뽑아내기 쉬운" 이라는 표현보다는, **"특정 유형의 워크로드와 대규모 시스템에서 최고 수준의 처리량과 자원 효율성을 달성하기 위한 강력한 선택지"** 라고 이해하는 것이 더 정확합니다.

**쉬운 프로그래밍인가?** 에 대한 답은 **"특정 상황에서는 그렇지만, 항상 그렇지는 않다"** 입니다.

리액티브 프로그래밍, 특히 비동기 논블로킹(Non-Blocking) I/O 모델을 기반으로 하는 경우, 서버 애플리케이션의 **처리량(Throughput)**과 **자원 효율성**을 극대화하는 데 매우 강력한 도구임은 분명합니다.

### 리액티브 프로그래밍의 성능 이점 (서버 기준)

1. **높은 동시성 처리 및 처리량 증가**
1. **자원 효율성**
1. **응답성 향상**
### 리액티브 프로그래밍의 한계 및 고려사항

하지만 리액티브 프로그래밍이 모든 상황에서 만능의 해결책은 아닙니다. 다음과 같은 단점과 고려사항이 있습니다.

1. **높은 학습 곡선 및 복잡성**
1. **모든 작업에 적합하지 않음**
1. **생태계 지원**
1. **역압(Backpressure) 관리의 어려움**
### 결론

서버 환경에서 리액티브 프로그래밍은 다음과 같은 경우에 **매우 강력한 성능 이점**을 제공합니다.

- **높은 동시 요청 처리**가 필요한 대규모 서비스
- **I/O 바운드 작업**이 주를 이루는 애플리케이션 (데이터베이스 조회, 외부 API 호출, 네트워크 통신 등)
- **자원 효율성**을 극대화하여 서버 비용을 절감하고자 하는 경우
하지만 **개발 복잡도 증가, 학습 곡선, 그리고 특정 워크로드(CPU 집약적)에 대한 비효율성**이라는 단점도 명확합니다.

따라서 "가장 성능을 뽑아내기 쉬운" 이라는 표현보다는, **"특정 유형의 워크로드와 대규모 시스템에서 최고 수준의 처리량과 자원 효율성을 달성하기 위한 강력한 선택지"** 라고 이해하는 것이 더 정확합니다.

## Spring WebFlux와 Reactor

Spring WebFlux와 Reactor는 **깊은 관계**를 가지고 있습니다. 간단히 말하면, **Spring WebFlux는 Reactor를 기반으로 만들어진 리액티브 웹 프레임워크**입니다.

### Reactor는 무엇인가요?

**Project Reactor**는 JVM 기반의 **비동기 논블로킹 애플리케이션**을 구축하기 위한 **리액티브 라이브러리**입니다. 주요 특징은 다음과 같습니다:

- **Reactive Streams 구현체**: Reactor는 Reactive Streams 사양을 구현한 라이브러리 중 하나입니다. Reactive Streams는 비동기 스트림 처리를 위한 표준으로, 역압(Backpressure) 메커니즘을 포함하여 생산자(Publisher)와 소비자(Subscriber) 간의 데이터 흐름을 효율적으로 제어합니다.
- **Mono와 Flux**: Reactor는 두 가지 핵심 Publisher 타입을 제공합니다.
- **논블로킹(Non-Blocking)**: Reactor는 스레드가 결과를 기다리는 동안 다른 작업을 수행할 수 있도록 하여 리소스 효율성을 높입니다.
- **스케줄러(Scheduler)**: Reactor는 스레드 관리자 역할을 하는 스케줄러를 제공하여, 리액티브 시퀀스에서 작업이 실행되는 스레드를 제어할 수 있게 합니다. 이를 통해 복잡한 멀티스레딩 로직을 손쉽게 구현할 수 있습니다.
- **다양한 연산자(Operators)**: `map`, `flatMap`, `filter` 등과 같이 데이터를 변환하거나 조합하는 수많은 연산자를 제공하여 비동기 데이터 스트림을 유연하게 처리할 수 있습니다.
### Spring WebFlux와 Reactor의 관계

- **기반 기술**: Spring WebFlux는 리액티브 스택 웹 프레임워크이며, 그 내부적으로 **Project Reactor를 핵심 기반 기술**로 사용합니다. 즉, Spring WebFlux를 사용하면 자연스럽게 Reactor의 `Mono`와 `Flux` 타입을 사용하여 비동기 논블로킹 웹 애플리케이션을 개발하게 됩니다.
- **패러다임 전환**: 전통적인 Spring MVC가 요청당 스레드를 할당하는 Blocking 방식인 반면, Spring WebFlux는 Reactor의 논블로킹 특성을 활용하여 소수의 스레드로 많은 동시 요청을 효율적으로 처리하는 **이벤트 루프 모델**을 따릅니다.
- **공식 지원**: Spring Framework 5부터 리액티브 프로그래밍을 위해 Reactor가 공식적으로 지원되는 라이브러리입니다.

---

*Originally published in [Notion](https://www.notion.so/Reactive-Programming-221eef64a1ca80889f2be8a4c6d10e98) on June 29, 2025*